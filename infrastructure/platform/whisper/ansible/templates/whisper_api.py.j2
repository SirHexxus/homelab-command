#!/usr/bin/env python3
"""
Simple Whisper API Server - OpenAI-compatible endpoint for faster-whisper
"""

import os
import tempfile
from typing import Optional

from fastapi import FastAPI, File, Form, UploadFile, HTTPException
from fastapi.responses import JSONResponse, PlainTextResponse
from faster_whisper import WhisperModel

# Configuration
MODEL_NAME = os.getenv("WHISPER_MODEL", "{{ whisper_model }}")
DEVICE = os.getenv("WHISPER_DEVICE", "{{ whisper_device }}")
COMPUTE_TYPE = os.getenv("WHISPER_COMPUTE_TYPE", "{{ whisper_compute_type }}")

app = FastAPI(title="Whisper API", description="OpenAI-compatible Whisper STT API")

# Load model at startup
print(f"Loading Whisper model: {MODEL_NAME} (device={DEVICE}, compute_type={COMPUTE_TYPE})")
whisper_model = WhisperModel(MODEL_NAME, device=DEVICE, compute_type=COMPUTE_TYPE)
print("Model loaded successfully!")


@app.get("/")
async def root():
    return {"status": "ok", "model": MODEL_NAME}


@app.get("/health")
async def health():
    return {"status": "healthy", "model": MODEL_NAME}


@app.get("/v1/models")
async def list_models():
    return {
        "object": "list",
        "data": [{"id": MODEL_NAME, "object": "model", "owned_by": "local"}]
    }


@app.post("/v1/audio/transcriptions")
async def transcribe(
    file: UploadFile = File(...),
    model: Optional[str] = Form(None),
    response_format: Optional[str] = Form("json"),
    language: Optional[str] = Form(None),
):
    """OpenAI-compatible transcription endpoint"""
    suffix = os.path.splitext(file.filename)[1] if file.filename else ".wav"

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:
            content = await file.read()
            tmp.write(content)
            tmp_path = tmp.name
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to process file: {str(e)}")

    try:
        segments, info = whisper_model.transcribe(tmp_path, language=language, beam_size=5)
        segments_list = list(segments)
        text = " ".join([seg.text.strip() for seg in segments_list])

        if response_format == "verbose_json":
            return {
                "task": "transcribe",
                "language": info.language,
                "duration": info.duration,
                "text": text,
            }
        elif response_format == "vtt":
            lines = ["WEBVTT", ""]
            for seg in segments_list:
                start = _fmt_ts_vtt(seg.start)
                end = _fmt_ts_vtt(seg.end)
                lines.append(f"{start} --> {end}")
                lines.append(seg.text.strip())
                lines.append("")
            return PlainTextResponse("\n".join(lines), media_type="text/vtt")
        elif response_format == "srt":
            lines = []
            for i, seg in enumerate(segments_list, 1):
                lines.append(str(i))
                lines.append(f"{_fmt_ts_srt(seg.start)} --> {_fmt_ts_srt(seg.end)}")
                lines.append(seg.text.strip())
                lines.append("")
            return PlainTextResponse("\n".join(lines), media_type="text/plain")
        else:
            return {"text": text}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Transcription failed: {str(e)}")
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


@app.post("/v1/audio/translations")
async def translate(
    file: UploadFile = File(...),
    model: Optional[str] = Form(None),
    response_format: Optional[str] = Form("json"),
):
    """Translate audio to English"""
    suffix = os.path.splitext(file.filename)[1] if file.filename else ".wav"

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:
            content = await file.read()
            tmp.write(content)
            tmp_path = tmp.name
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to process file: {str(e)}")

    try:
        segments, info = whisper_model.transcribe(tmp_path, task="translate", beam_size=5)
        text = " ".join([seg.text.strip() for seg in segments])

        if response_format == "verbose_json":
            return {"task": "translate", "language": info.language, "duration": info.duration, "text": text}
        return {"text": text}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Translation failed: {str(e)}")
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def _fmt_ts_vtt(seconds: float) -> str:
    h, r = divmod(seconds, 3600)
    m, s = divmod(r, 60)
    return f"{int(h):02d}:{int(m):02d}:{s:06.3f}"


def _fmt_ts_srt(seconds: float) -> str:
    h, r = divmod(seconds, 3600)
    m, s = divmod(r, 60)
    ms = int((s % 1) * 1000)
    return f"{int(h):02d}:{int(m):02d}:{int(s):02d},{ms:03d}"


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port={{ whisper_port }})
